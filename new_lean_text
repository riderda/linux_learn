ls :
	-i 查看inode值
	-d 只显示目录,不显示内容
	-F 在目录后加个/
	-R 递归
cp :
	-i 查询是否操作
ln :
	-s 软链接
mv :
	-i 查询是否操作
rm :
	-i 查询是否操作
	-f 强制
	-r 递归
mkdir :
	-p 多级目录和子目录
history:查看最近的指令,最近1000条
	-a: 写入历史
	-n: 写入其他端口的历史
	!(num):调用第num条命令
	!!:调用上一条指令
文件查询:
file://查看文件类型
cat :
	-n 给内容加上行号
	-b 只给有文本的行加上行号
	-T 去除制表符
less ://more的增强版

tail ://查看部分文件,默认显示文件末尾的10行
	-n num //显示末尾num行
head : //查看部分文件,默认显示文件的前10行
	-(num) /查看前num行的内容
打包和压缩:
	xz对应unxz
	gzip 解压对应 -d参数
	bzip2 解压对应 -d参数
	tar:
		-c:创建
		-x:释放
		-t:列出
		-------
		-z:使用gzip
		-j:使用bizp2
		-u 更新文件到包里
		-r 追加文件到包里
		-------
		-v:列出详细信息
		-f:后面紧跟文件名
		-------
		-C:选择解包的位置
------------------------进程-----------------------------------
进程(process)

ps :探查进程//默认只能查询到当前控制台下用户的进程
关键字: PID(process ID) , TTY(终端)	
	-e 显示所有进程
	-f 显示更多额外输出
		UID : 启动进程的用户

///////////////////////////////////////////////////////////
杂:

	& 后台指令
	
		PID : 进程的进程ID
		jobs -l jobs的详细信息
	

		PPID : 父进程的进程ID
		C :生命周期中的CPU利用率
		STIME : 进程启动的系统时间
		TTY : 进程启动的终端设备
		TIME : 运行程序需要的累计cpu
		CMD : 启动的程序名称
	-l 显示更多的输出
		F : 内核分配给进程的系统标记
		S : 进程的状态
		PRI :　优先级(越小越优先)
		NI : 谦让值
		ADDR : 进程的内存地址
		SZ : 如果进程被换出,所需交换空间的大小(大致)
		WCHAN : 进程休眠的内核函数的地址

top:实时监测进程
	PID:
	USER:
	PR:优先级
	NI:谦让值
	VIRT:占用虚拟内存的总量
	RES:占用物理内存的总量
	SHR:和其他进程共享的内存总量
	S:进程的状态(D可中断的休眠状态,R在运行的状态,S休眠的状态,T跟踪状态或停止状态,Z僵化状态)
	%CPU:占用CPU的时间比例
	%MEN:使用内存占用可用内存的比例
	TIME+:启动为止的CPU时间总量
	COMMAND:启动的程序名

---------------------------------------------------------
进程信号
	1:挂起
	2:中断
	3:结束运行
	9:无条件终止
	11:段错误
	15:尽可能终止
	17:无条件停止运行,但不终止
	18:停止或暂停,但继续在后台运行
	19:在17和18之后恢复运行

kill:给PID发送信号
	//要发送进程信号,只能是进程属主或者是root用户
	-s : 指定信号

killall://支持进程名查找

----------------------------------------------------------
检测磁盘空间:
	mount://默认输出系统挂载的设备列表
	//提供四部分信息
	媒体的设备文件名
	媒体挂在到虚拟目录的挂在点
	文件系统类型
	已挂载媒体的访问状态

	-a
	-f
	-F
	-v
	-I
	-l
	-n
	-p num
	-s
	-r
	-w
	-L label
	-U uuid
	-O
	-o//允许添加特定的选项
		ro
		rw
		user
		check=none
		loop
	
	umount://卸载设备
	格式: umount [directory | device]

	df://查看磁盘使用情况
		-h:易读的形式显示
	//lsof [directory | device]//查看进程信息

	du://查看某个目录的磁盘使用情况,默认是当前目录
	查看的大小单位是磁盘块数
	-c :显示所有已列出的文件的总大小//没什么用,只会在最后显示,文件一多根本没什么意义
	-h :易读形式显示
	-s : 显示每个输出参数的总计

////////////////////////////////////////////////////////////////////////////////////

处理数据文件
sort://按默认语言对文本文件进行数据行排序
	-n:把数字识别成数字而不是字符
	-M:识别三字符的月份名
	-b:忽略起始的空白
	-c:不排序,如果数据无序也不报告
	-d:仅考虑空白和字母
	-g:支持浮点数和科学计算法的排序
	-m:合并两个已排序的文件
	-R:指定随机排序
	-r:逆序
	-k: --key=pos1[,pos2] 指定从pos1开始,如果指定了pos2,就到pos2结束//一般和-t一起使用,指定使用哪个字段作为排序依据
	-t:指定一个用来区分键位置的字符//遇到多字段的行的时候,用于指定字段的区分键

搜索数据://行搜素
	grep [options] pattern [file]
		-v:反向搜索(不匹配的行)
		-n:显示行号
		-c:显示匹配次数,不显示匹配的行
		-e:指定多个匹配模式

协程:
	coproc:创建子shell,并把命令置入后台
	eg: coproc sleep 3000//后台的的结果是coproc COPROC sleep 3000 &
	使用拓展语法:
		eg: coproc My_Job { sleep 3000; }
		注:这样可以命名协程,但{}左右都要空格,命令结尾必须是分号";",多条指令建议全部有分号

理解shell的内建指令
	外部指令:也称文件系统指令,是存在于bash之外的程序,通常位于/bin,/usr/bin,/sbin,/usr/sbin,当外部指令执行的时候会创建一个子进程
		which://查看指令位置//只能查看外部命令
		whereis 查看命令位置以及在帮助文档所在的位置
	内建命令://不需要创建子进程
		type://与上方的作用差不多//可以查看命令是外部还是内建
			-a :显示命令的两种实现
	
	命令别名://alias//只在当前shell有效
		-p:查看当前可用的别名
		
/////////////////////////////////////////////////////////////////////////////////
全局环境变量//对于shell和所有子shell都是可见的
	printenv或者env
	要显示个别环境变量的时候,使用printenv
局部环境变量//只能在定义他们的shell中可见
	set:显示为某个进程设置的所有环境变量,包括局部变量,全局变量和用户定义变量
	用户定义的变量是局部的

	export:导出局部变量,使其成为全局变量//只能在当前会话//变量不用取值,故不需要加$
		注意,子shell并不能用export改变父shell的变量
	
	unset://删除环境变量

PATH环境变量:
	$PATH:用于命令和程序查找的目录
		添加PATH:
			eg: PATH=$PATH:/home/chenweida
				添加PATH:
					eg: PATH=$PATH:/home/chenweida/computer_organization_learn
					如果希望子shell也找到路径,记得导出
					但这个办法只能维持到退出或者重启
------------------------------------------------------------------------------
登录shell:
	登陆时会从5个不同的文件读取命令:
		/etc/profile
		$HOME/.bash_profile
		$HOME/.bashrc
		$HOME/.bash_login
		$HOME/.profile

交互式shell:
	//有点复杂,总之如果bash不是登录的时候启动,那么就是交互式shell,而且不会访问/etc/profile,只会检查用户HOME下的.bashrc文件

非交互式shell:
	系统执行shell脚本的时候启用
-------------------------------------------------------------------------------

环境变量持久化:
	可以在/etc/profile下创建一个.sh的文件
	或者写在$HOME/.bashrc
-------------------------------------------------------------------------------

环境变量持久化:
	可以在/etc/profile下创建一个.sh的文件
	或者写在$HOME/.bashrc

///////////////////////////////////////////////////////////////////////////////

数组变量:
	myarr=(one two three four five)
	数组只能通过下标取值,[*]表示所有元素

///////////////////////////////////////////////////////////////////////////////
linux文件权限

/etc/password
username:password:uid:gid:remarks:HOME:shell//基本格式//早期password的位置放的是加密的密码,现在就剩个x

/etc/shadow
username:加密后的密码:自修改过后的天数:多少天后才能更改密码:多少天后必须改密码:密码过期前多少天提醒更改密码:密码过期后多少天禁止该用户:用户被禁用的日期:预留

添加用户
useradd -D
查看系统下的一些默认值//如果创建用户的时候不指定具体的值,则使用这些值

useradd参数
	-c 描述
	-d 为主目录指定名字
	-e 用yyyy-mm-dd格式指定过期的日期
	-f 指定过期多少天被禁用,0表示立即,-1表示不启用
	-g 指定gid
	-G 指定附加组
	-k 
	-m 创建用户的HOME目录
	-M 不创建HOME目录
	-n 创建一个与用户名同名的新组
	-r 创建系统用户
	-p 指定密码
	-s 指定登录shell
	-u 指定uid

更改useradd的参数
	-D 
		-b 更改默认的HOME
		-e 更改默认的过期日期
		-f 更改默认的用户过期到被禁用的天数
		-g 更改默认组名称或者gid
		-s 更改默认登录的shell
	
删除用户
userdel
//默认之后删除/etc/password中的信息
	 -r 删除用户的HOME和邮件目录

修改用户
usermod//用来修改/etc/password的大部分字段
	-c
	-e
	-g
	-l 修改登录名
	-L lock
	-p 修改密码
	-U unlock

passwd 和 chpasswd
	-e 强制用户下次登录时修改密码

	chpasswd可以读取用户名:密码的列表
		eg: chpasswd < user.txt
chsh chfn chage
	chsh //修改登录shell
		eg: chsh -s /bin/csh test
	chfn:书本解释的比较模糊,具体再查
	chage
		-d 设置上次修改密码到现在的天数
		-E 设置密码过期的日期
		-I 设置面膜过期到锁定的天数
		-m 设置修改密码期间需要多少天
		-w 设置密码过期前多少天开始出现提醒

su//切换用户,不用麻烦的login,但是切换的没有登陆彻底
	缺省默认root
	- //加横杠类似于登陆
-----------------------------------------------------------------
使用linux组
	/etc/group
	//基本格式
	组名:组密码:gid:属于这个组的用户列表

创建新组
	groupadd 组名
	为用户添加组:usermod -G 组名 用户名

	groupmod
		-n 修改组名
		-g 修改gid
	gpasswd
		-a 用户名 组名//将用户加入该组
		-d 用户名 组名//将用户移出该组
	groupdel 组名//删除该组
-----------------------------------------------------------------

理解文件权限
	- 文件
	d 目录
	l 链接
	c 字符型设备
	b 块设备
	n 网络设备

	r 可读
	w 可写
	x 可执行

	eg:-rwxrwxr-x 1 rich rich 4882 2010-09-18 13:48 myprog
		|  |  |
		|  |  |
	 user group other 
	 r 权值4
	 w 权值2
	 x 权值1

	每个文件被创建的时候,权限是666,然后减去umask值//比如我现在的umask值是02,所以创建的文件权限是644
	每个目录的被创建的时候,权限是777,所以生成的目录的权限值是744
	主要是用于屏蔽某个不想授予的权限
-----------------------------------------------------------------
改变安全性设置

改变权限
	chmod options mode file
		-R 递归更改权限
	//另一种写法
		[ugao] [+-=] [rwx...]
		u user        X 如果对象是目录或者已经有了执行权限,则赋予权限
		g group       s 运行时重新设置uid或gid
		o other       t 保留文件或目录
		a all         u 设置属主权限
					  g 设置属组权限
					  o 设置其他用户的权限
		
改变所属关系
chown options owner[.group] file
	eg: chown dan.shared file//把file的属主改为dan,属组改为group
		chown .rich file // 把file的属组改为rich
chgrp 组名 文件
	//更改文件属组

--------------------------------------------------------------
共享文件

设置用户id (suid) :当文件被用户使用的时,程序会以文件属主的权限运行
设置组id (sgid) : 对文件来说,程序会以文件属组的权限运行;对目录而言,目录中创建的新文件会以目录的默认属组作为默认属组
粘着位:进程结束后文件还驻留在内存中

//很有趣的操作,linux里谁创建的文件属主就是谁,属组是默认属组,这样在共享文件里面就要经常改,很麻烦.但是有了suid和sgid可以解决,具体例子看书本或者百度
xxx
suid位 sgid位 粘着位

