echo
	-n 不换行
	-e 启用转义
首先shell的大小写敏感

shell的变量默认是字符串

变量的定义：
	shell里面有三种引号。'',"",``.
	单引号：将内容都作为普通字符
	双引号：只解析 $ , \ , ' , "
	反引号：将内容作为shell指令

变量的作用域：
	函数是可以访问到全局的
	声明为局部变量：lcoal
坑点：
	$代表取变量的值，定义和赋值的时候不需要使用。
	建议写成 “${}” 这样的格式。
系统变量：
	$n 解释为参数，文件名为 $0 
	$# 命令行参数的个数
	$? 上一个状态码
	$* 返回所有参数，视为一整个字符串
	$@ 返回所有参数，将每个参数分别用字符串表示
	$$ 返回进程ID
\在shell也是转义

环境变量：
	PATH
	HOME
	COLUMNS
	HISTFILE
	HISTSIZE
	IFS
	LOGNAME
	SHELL
	TERM
	TMOUT
	PWD
还可以用set | more 展示所有环境变量
	set://展示当前环境变量

变量赋值：
	viaoshi_name=value
	注：等号前后不能有空格
清除变量：
	unset variable_name

命令替换://从命令输出中提取信息
反引号：
	`shell_command`
	$(shell_command)
	上述两者等价


条件测试和判断语句：
	test 和 [
	
用法：
	test expression  or [ expression ]
坑点:   [ 作为命令，记住要与表达式有空格

字符串运算符：
	string 判断是否为空
	string1 = string2 判断是否相等
	string1 != string2 判断是否不相等
	-n string 判断是否非空串
	-z string 判断是否空串 注：与第一条看似相同，但两者不一样，建议用这条！
坑点：“=”，“!=”，“-z”等这些符号左右两边一定要有空格

整数运算符：
	test number1 op number2
	-eq =
	-ne !=
	-gt >
	-lt <
	-ge >=
	-le <=

文件测试：
	test op file
	-a 判断存在 注：这玩意和逻辑运算符的&&是一样的
	-e 满足上述的情况而使用，与 “-a” 一样
	-b 块文件
	-c 字符文件
	-d 目录
	-s 非空文件
	-f 存在的常规文件
	-w 可写
	-L 存在的符号链接
	-u 设置suid位
	-r 可读
	-x 可执行

逻辑运算符：
	! 
	-a &&
	-o ||

if语句：
if expression
then
	statement1
	...
fi

或者
if expression; then
	statement
	...
fi

空命令：“:”,不做任何事，退出状态永远是0

类似scanf，shell有 read 用于读取键盘输入
shell是动态语言，类型之间可以发生隐式转换

有if elif 进行多条件判断

退出程序：
	exit status

多条件判断语句：
case variable in
value1)	//右边的圆括号
	statement
	...
	;; //类似break
value2)
	statement
	...
	;;
...
*) //default
	statement
	...
	;;
esac //case倒过来写，代表结束

算术运算符：
	和py的基本相同，有 ** 但没有 //
	`expr expression`
	$((...))
	$[...] 同上
	let 
坑点：
	运算符两边一定要有空格！！！
	expr不能进行幂运算，而且里面的 “()”，“*”，都要转义处理，注意反引号！！！
拥有和C一样的位运算符，复合运算符，自增自减运算符！
常量进制：
	eg：20 ， 020 ， 0x20
	又或者
	eg：x=2#10000 , x=8#123 , x=16#32...类似这种写法

循环结构：
for循环：
	for variable in {list}
	do
		...
	done
或者
	for variable in {start..end..step}
	do
		...
	done
还有很多灵活的用法，比如：for var in $(ls)之类
或者
	for var
	do
		...
	done
	像这种默认列表为参数
或者c风格的for循环语句
	for((i=1;i<10;i++))
	do	
		...
	done
for循环处理数组，等我学完数组再来补充

until循环语句：
	until expression
	do
		...
	done
坑点：上面的条件不是循环条件，而是退出条件
	
while循环语句：
	while expression
	do
		...
	done
还有break和continue控制，基本和C一样，但是后边可以加参数，表示跳出的循环数
eg：break 2 或者 continue 2 

/////////////////////////////////////////////////////////////////////////////////
使用多个命令
	command1;command2
	//中间用分号隔开

////////////////////////////////////////////////////////////////////////////////
重定向
	> 输出重定向
	>> 输出重定向(追加)

	< 输入重定向
	内联输入重定向:
	<< 结束符号
	 //里面随便写
	 结束符号
	 //代表结束,结束符号只能单独占一行

管道
	命令 | 命令
	//经常用于一个命令的输出作为另一个命令的输入

数学运算
	expr:
		arg1 | arg2 如果arg1不是null或零值,返回arg1 ,否则返回arg2
		arg1 & arg2 如果没有参数是null或零值,返回arg1,否则返回0
		+-*/% >< <= >= 这些符号的定义都和常见的的定义一样
		STRING : REGEXP //如果匹配到.就返回该模式
		match STRING REGEXP //和上面一样
		substr STRING POS LENGTH //返回从pos开始,长度为length的子字符串
		index STRING CHARS //返回在string中chars的位置,否则返回0
		length STRING //返回string的长度
		+ TOKEN //将token解析成字符串
		(表达式) 返回表达式的值
		//注意一些符号需要转义
		
	$[ 表达式 ]://好像不需要空格                           //这个和条件判断的[] 不一样好像
	//bash里面没有提供浮点数计算
	
	浮点数解决方案:
	bc:
	在脚本中使用bc:
	var=$(echo "options; expression" | bc)//适合短数据的运算
	
	//使用内联输入重定向
	var=$(bc << EOF
	options
	statements
	expressions
	EOF
	)
	eg:
		var5=$(bc << EOF
		scale=4
		a1 = ($var1*$var2)//a1不能在接下来的shell里面调用到,只能在计算器使用
		a2 = ($var2 * $var4)//计算器里面没有太多关于空格的要求
		EOF
	bc没有幂运算
退出脚本:
	查看退出状态
	$?
		0 
		1  一般未知错误
		2  不适合的命令
		126  命令不可执行
		127  没有找到命令
		128 无效的退出参数
		128+x 与信号x相关的重要错误
		130 ctrl+c终止的命令
		255 正常范围之外的退出状态码
	
	exit://允许自定义退出码
		退出码只能在0~255	
		
//////////////////////////////////////////////////////////////////////////////////
结构化命令
if-then
//注意,如果使用这种command的操作,那只能利用返回码
	格式:
		if command
		then
			command
		fi
		//if接命令,如果命令的返回码是0,则then部分会被执行
		if command ;then
			command 
		fi
		//也可以写成这个样子

if-then-else
	格式:
	if command
	then
		command
	else
		command
	fi

if-elif-then
	if command
	then
		command
	elif command
	then 
		command
	else
		command
	fi
	//在elif语句中,紧跟着的else属于elif,不属于之前的if-then

test命令://用于生成返回码
	格式:test condition
	//注意,test后面没有condition的时候是返回非零值
	
	//test 字符串 //用于判断字符串是否有内容,如果 "" 则返回非零值
	test可以判断的三类条件:
		数值比较:
			-eq =
			-ge >=
			-gt >
			-lt <
			-le <=
			-ne !=
			可惜,只能进行整数的比较

		字符串比较:
			str1 = str2 检查str1是否和str2相同
			str1 != str2
			str1 < str2 //注意大于号要转义,否则会被理解为重定向//而且大小的比较是根据ascll顺序
			str1 > str2
			-n str1 检查str1的长度是否非0
			-z str1 检查str1的长度是否为0//未被定义的字符串长度是0,默认是所有变量都是字符串
			//坑:不要对数值使用字符串比较的符号,否则结果意想不到
		文件比较;
			-d 存在且是目录
			-e 存在
			-f 存在且是文件
			-r 存在且可读
			-s 存在且非空
			-w 存在且可写
			-x 存在且可执行
			-O 存在且属于当前用户
			-G 存在且默认组与当前用户线条
			file1 -nt file2 file1比file2新
			file1 -ot file2 file1比file2老
[ condition ]: //和test一样的功能,但注意要有空格
	复合条件测试:
		[ condition ] && [ condition ]
		[ condition ] || [ condition ]

if-then高级特性
	双括号:
		(( expression )) //主要针对数值,除了test中的数学运算符以外还有以下这些
		//c风格操作
		var++
		var--
		++var
		--var
		!
		~ 位求反
		**
		>>
		<<
		&
		|
		&&
		||
	//不支持浮点数,不仅可以用于判断,还可以用于赋值之类的
	eg:
		if (( $var *82 > 90));then
			(( var2 = $var1 ** 2))//快看,等号终于不用贴在一起了
		fi
	
	方括号:
		[[ expression ]]//不是所有shell都支持,提供了针对字符串的高级特性,使用test的字符串比较,还提供了正则
			//从例子上看,好像是linux的正则,后面有继续说明
----------------------------------------------------------------------------------------

case命令
	格式:
		case var om
		pattern1 | pattern2) command;;//可以使用 | 进行模式选择或
		pattern3) command ;;//记得结尾;;代表break
		*) command;;
		esac


