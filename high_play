//////////////////////////////////////////////////////////
----------------------------------------------------------
基本的脚本函数
	创建函数
		function name {
			commands
		}
		or
		name(){

		}
	
	使用函数
		name
		//就这样
		//函数创建必须在使用之前
		//个人理解:函数是类似于自己的命令,所以允许使用以前使用命令的方法去调用函数
		//允许重定义,但是会覆盖原来的函数;这跟java的重载不一样
-----------------------------------------------------------
返回值
	默认退出码
		默认情况下,函数的退出码是最后一条命令返回的退出码,所以在函数结束后可以使用 $? 获取

		return
		//如果需要的话,函数结束就立刻获取返回值
		//返回值只能在0-255之间
		//要返回更大值或者字符串就需要其他手段了

	使用函数输出
		result=`函数名`

		eg:
			db1(){
				echo "hello"
			}

			result=$(db1)
		//result = hello
	//通过这种手段可以获取浮点数和字符串
------------------------------------------------------------
在函数中使用变量
	向函数传递参数
	
	addem() {
		if [ $# -eq 0 ] || [ $# -gt 2 ]
		then 
			echo -1
		elif [ $# -eq 1 ]
		then 
			echo $[$1 + $1}
		else
			echo $[$1 + $2]
		fi
	}
	
	//
		我之前的猜想是函数是命令,所以参数的传递和命令的参数传递一样
		$1,$2 .....
		$# , $@ , $* 之类的
		所以不能直接对外部脚本的参数进行操作
		需要手动传参
	//

	在函数中处理变量
	* 全局变量
		在函数外被定义并赋值.如果变量在函数内被赋予了新值,那么在脚本中引用该变量时,新值依然有效.但这个方法往往很蠢

	* 局部变量
		无需在函数中使用的全局变量,函数内部使用的变量都可以声明成局部变量.在变量声明的前面加上 local 关键字
		local关键字保证变量只局限在该函数中,如果脚本中在该函数之外有相同名字的变量,那么shell将会保持这两个变量的值是分离的
---------------------------------------------------------------
数组变量和函数
	向函数传数组参数
		eg:
			testit() {
				echo "参数是: $@"
				thisarray=$1 #尝试将第一个参数作为变量保存,即将数组保存
				echo "这个参数数组是 ${thisarray[*]}"
			}

			myarray=(0 1 2 3 4 5)
			echo "数组是 ${myarray[*]}"
			testit $myarray
		//
			结果
			数组是 0 1 2 3 4 5
			这个参数数组是 0
		//
		//我是不是可以理解为传入的数组会被拆成多个参数,这样$1就只有数组的第一个值

		eg:
			testit() {
				local newarray
				newarray=(`echo "$@"`)#将参数重新拼成一个数组,最外边是数组的标准
				echo "这个参数数组是 ${newarray}"
			}
		//
			结果
			这个参数数组是 0 1 2 3 4 5
		//

	从函数返回数组
		function() {
			local arr
			arr=(`echo $@`)
			echo ${arr[*]}
		}
----------------------------------------------------------------
函数递归	
	fact(){
		if [ $1 -eq 1 ]
		then
			echo 1
		else
			local temp=$[ $1 - 1 ]
			local result=$(fact $temp)
			echo $[ result * $1 ]
		fi
	}
----------------------------------------------------------------
创建库
	//
		如果你创建了一个脚本,但是你想在另一个脚本里调用,你会遇到shell函数的作用域的问题,和环境变量一样,shell函数只在定义它的会话里有效.

	./脚本名 //这是在新的shell里运行
	source 脚本名 //在当前shell里运行该脚本
	又名 . (点操作符)
	. 脚本名
	. ./脚本名
	//
----------------------------------------------------------------

在命令行上使用函数
	. ./脚本名 //加载需要的脚本,然后就可以在这个shell里使用函数了,但是函数命名要小心,重名了很麻烦
	eg:
	:(){
		:|:&
	}
	:
	//恶臭炸弹
	一句话版本: :(){ :|:&};:
	//单行函数在第一个花括号后需要空格,函数体里的指令后面需要用 分号; 或者 和号& 修饰
	
	在.bashrc文件中定义函数
	使用 source 加载脚本 或者直接在里面创建函数
	//主目录下的.bashrc是每次启动shell都会自动加载的一个脚本
